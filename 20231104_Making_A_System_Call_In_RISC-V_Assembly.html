<html>
<head>
<title>Making a Linux system call using RISC-V assembly</title>
<style>
body {
	background-color: #F0F0F0;
	margin-left: 24pt;
	margin-right: 24pt;
}
h1, h2 {
	color: #222222;
	text-align: left;
	font-family: sans-serif
}
p {
	color: #222222;
	font-family: serif;
	font-size: 12pt;
}
pre {
	margin-left: 14pt;
	padding-top: 2pt;
	padding-bottom: 2pt;
	padding-right: 4pt;
	padding-left: 4pt;
	background-color: #F8F8F8;
}
</style>
</head>
<body>
<p><a href="index.html">back to index</a></p>
<h1>Making a Linux system call using RISC-V assembly</h1>

<p><em>How to make a minimal program that calls <code>sys_exit()</code></em></p>

<p>The interface to make a Linux system call on RISC-V can be found in the manpages
in the <a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/">Linux kernel manpages git repository</a></p>

<pre><code>$ man 2 syscall 
Arch/ABI    Instruction           System  Ret  Ret  Error    Notes
                                  call #  val  val2
-------------------------------------------------------------------
riscv       ecall                 a7      a0   a1   -

Arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
--------------------------------------------------------------
riscv         a0    a1    a2    a3    a4    a5    -
</code></pre>

<p>Basically, place the system call arguments into registers <code>a0</code> through <code>a5</code>,
the system call number in <code>a7</code>, and then invoke the <code>ecall</code> instruction.</p>

<p>A minimal program that runs without the standard library / C runtime harness
needs to call sys_exit when it finishes, so I decided to start with that as my
first program.</p>

<p>Looking at linux's <code>include/uapi/asm-generic/unistd.h</code> the syscall number for
sys_exit is</p>

<pre><code>#define __NR_exit 93
</code></pre>

<p>and looking at linux's <code>include/linux/syscalls.h</code> the interface is:</p>

<pre><code>asmlinkage long sys_exit(int error_code);
</code></pre>

<p>You can load immediates into <code>a0</code> and <code>a7</code> with risc-v's <code>li</code>
pseudoinstruction:</p>

<pre><code>li a0, 2   # exit status 2
li a7, 93  # syscall 93 is sys_exit
ecall
</code></pre>

<p>(The list of all the standard pseudoinstructions are listed in the section
"RISC-V Assembly Programmer's Handbook" of the <a href="https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf">The RISC-V Instruction Set
Manual</a>.)</p>

<p>I recall from memory that the default entrypoint for programs generated by <code>gcc</code>
on Linux is the <code>_start</code> label, but you can verify this by running <code>ld -verbose</code>
and noting</p>

<pre><code>ENTRY(_start)
</code></pre>

<p>in the output. So you need to put this label at the start of the code you'd like
to execute. You also need to instruct the assembler to make that symbol visible
externally by telling it</p>

<pre><code>.global _start
</code></pre>

<p>(The directives that you can use to control the gnu assembler is in the
<a href="https://sourceware.org/binutils/docs/as/Pseudo-Ops.html">Aseembler directives chapter of the GNU <code>as</code> Manual</a>)</p>

<p>Putting all this together in a file called <code>exit.s</code>, you get:</p>

<pre><code>.globl _start
_start:
        li a7, 93 # syscall 93 = exit
        li a0, 2  # exit code 2
        ecall
</code></pre>

<p>Assemble and generate an object file with the command:</p>

<pre><code>$ as -o exit.o exit.s
</code></pre>

<p>As a sanity check, you can disassemble the object file:</p>

<pre><code>$ objdump -d exit.o

exit.o:     file format elf64-littleriscv


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:   05d00893                li      a7,93
   4:   00200513                li      a0,2
   8:   00000073                ecall
</code></pre>

<p>Finally, link it to produce an ELF executable:</p>

<pre><code>$ ld -o exit.elf exit.o
</code></pre>

<p>And run it, and check the exit code:</p>

<pre><code>$ ./exit.elf
$ echo $?
2
</code></pre>

</body>
</html>
